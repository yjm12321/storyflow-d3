<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html">
<head lang="en">
    <meta charset="UTF-8">
    <title>StoryFlow: Tracking the Evolution of Stories</title>
    <link rel="stylesheet" type="text/css" href="lib/jquery-ui-themes-1.11.4/themes/flick/jquery-ui.min.css"/>
    <link rel="stylesheet" type="text/css" href="lib/jquery.sumoselect/sumoselect.css"/>
    <script type="text/javascript" src="lib/d3.v3.js"></script>
    <script type="text/javascript" src="lib/jquery-ui-1.11.4/external/jquery/jquery.js"></script>
    <script type="text/javascript" src="lib/jquery-ui-1.11.4/jquery-ui.min.js"></script>
    <script type="text/javascript" src="lib/jquery.sumoselect/jquery.sumoselect.js"></script>
</head>
<body>
<script type="text/javascript">
    var dataset = null;
    var svg = null;

    // Store configuration parameters for the algorithm and the visualization
    var options = {
        svg: {
            element: "#canvas",
            height: 1000,
            width: 16000,
            topPadding: 60
        },
        animation: {
            transitionDuration: 1000
        },
        characters: {
            interpolation: "monotone",
            class: "line",
            labelClass: "name",
            labelX: 4,
            labelDy: -4,
            sessionCoefficient: 2,
            strokeWidth: 4,
            highlightStrokeWidth: 8,
            highlightDuration: 400,
            nonHighlightedOpacity: 0.2,
            toKeep: null
        },
        locations: {
            interpolation: "monotone",
            fontSize: "30px",
            labelX: 30,
            labelDy: -10,
            padding: 20,
            opacity: 0.2,
            class: "locationPath",
            labelClass: "locationLabel",
            splitLength: 400
        },
        algorithm: {
            sweepingMaxIterations: 3
        }
    };

    $(document).ready(function () {
        svg = d3.select(options.svg.element).append("svg").attr("height", options.svg.height).attr("width", options.svg.width);

        // Runs the layout optimization algorithms and visualizes the result
        function buildDrawStoryFlow(path, options) {
            d3.json(path, function (error, json) {
                if (error)
                    return console.error(error);

                // Run the algorithm to optimize the layout
                dataset = annotateDataset(json, options);

                // First run of this dataset, load the characters into the select
                if (options.characters.toKeep == null) {
                    $('#characters').empty();
                    $('#characters')[0].sumo.reload();

                    options.characters.toKeep = dataset.characters.map(function (character) {
                        return character.id;
                    });

                    dataset.characters.forEach(function (character) {
                        $("#characters")[0].sumo.add(character.id, character.name);
                    });

                    // By default, draw all the characters
                    $("#characters")[0].sumo.selectAll();
                }

                drawStoryFlow(dataset, options);
            });
        };

        $("#dataset").selectmenu({
            width: 230,
            select: function (event, ui) {
                // Makes sure we reload the characters for the new dataset
                options.characters.toKeep = null;

                buildDrawStoryFlow(ui.item.value, options);
            }
        });

        $("#interpolation").selectmenu({
            width: 200,
            select: function (event, ui) {
                options.characters.interpolation = ui.item.value;
                options.locations.interpolation  = options.characters.interpolation;

                // Avoid recomputing the layout, just update the visualization
                drawStoryFlow(dataset, options);
            }
        });

        $("#characters").SumoSelect();

        $("#characters").change(function () {
            // Fetch the list of characters to display
            options.characters.toKeep = $("#characters").val();

            // Load the dataset and display
            buildDrawStoryFlow($("#dataset").val(), options);
        });

        // When the page loads for the first time, visualize the default dataset
        buildDrawStoryFlow($("#dataset").val(), options);
    });

    /**
     * Display the dataset using d3.js
     *
     * @param dataset the dataset to visualize
     * @param options configuration options
     */
    function drawStoryFlow (dataset, options) {
        // Set the colors of the characters and locations
        var characterColors = dataset.characters.length <= 10 ? d3.scale.category10() : d3.scale.category20();
        var locationColors  = dataset.locations.length <= 10 ? d3.scale.category10() : d3.scale.category20();

        // Assign each character a color
        for (i = 0; i < dataset.characters.length; ++i) {
            dataset.characters[i].d3 = {color: characterColors(i)};
        }

        // Assign each location a color
        for (i = 0; i < dataset.locations.length; ++i) {
            dataset.locations[i].d3 = {color: locationColors(i)};
        }

        // Compute the maximum number of characters in a time unit
        // (Useful for scaling the layout)
        var maxCharacters = dataset.d3.time.map(function (time) {
            return time.sortedCharacters.length;
        })
                .reduce(function (x, y) {
                    return Math.max(x, y);
                });

        // Create various scales
        var verticalScale = d3.scale.linear()
                .domain([0, maxCharacters])
                .range([options.svg.topPadding, options.svg.height]);

        var horizontalScale = d3.scale.linear()
                .domain([0, dataset.d3.time.length])
                .range([0, options.svg.width]);

        // Compute the path of each character
        for (var t = 0; t < dataset.d3.time.length; ++t) {
            var time = dataset.d3.time[t];

            // Since we use the characters in time.sortedCharacter, we need a way of knowing
            // how they are grouped together (in sessions)
            // characterGroups stores the number of sessions and how many characters it contains
            var characterGroups = time.locations.
                    map(function (x) {
                        return x.sessions.map(function (x) {
                            return dataset.sessions[x].members.length;
                        })
                    }).
                    reduce(function (x, y) {
                        return x.concat(y);
                    });

            var offset = 0;

            // We apply 'compation', drawing the characters which interact with each other
            // closer, by computing their mean Y coordinate and distributing them more closely around it
            characterGroups.forEach(function (charactersInSession) {
                var mean = 0;

                for (i = 0; i < charactersInSession; ++i) {
                    mean += verticalScale(offset + i);
                }

                mean /= charactersInSession;

                for (i = 0; i < charactersInSession; ++i) {
                    // Fetch the character with the given ID
                    var character = dataset.characters.filter(function (character) {
                        return character.id == time.sortedCharacters[offset + i];
                    })[0];

                    if (character.isRemoved)
                        continue;

                    if (character.d3.points == undefined)
                        character.d3.points = [];

                    // Distribute it around the mean according to its position in the session
                    character.d3.points.push({
                        x: horizontalScale(t),
                        y: mean + ((verticalScale(offset + i) - mean) / options.characters.sessionCoefficient)
                    });
                }

                // Keep track of the index in time.sortedCharacters
                offset += charactersInSession;
            });
        }

        // Store the boundary points for each location
        // We will store the points that define the 'shape' of each location
        // The points are sorted increasingly according to the X coordinate
        // For each 'time', we will store the top (minimum Y) and bottom (maximum Y) points,
        // which allows us to use d3.area to visualize the locations

        // TODO: Optimize, very inefficient
        for (var t = 0; t < dataset.d3.time.length; ++t) {
            var time = dataset.d3.time[t];

            for (i = 0; i < time.locations.length; ++i) {
                var sessions = time.locations[i].sessions;

                for (k = 0; k < sessions.length; ++k) {
                    var session   = dataset.sessions[sessions[k]];
                    var location   = dataset.locations[session.location];

                    for (var h = 0; h < session.members.length; ++h) {
                        var character   = dataset.characters.filter(function (character) {
                            return character.id == session.members[h];
                        })[0];

                        if (location.d3.points == undefined)
                            location.d3.points = [];

                        character.d3.points.forEach(function(characterPoint) {
                            // We are only interested in the points belonging to this 'time'
                            if (characterPoint.x != horizontalScale(t))
                                return;

                            // No points added -> nothing to check
                            if (location.d3.points.length == 0)
                                location.d3.points.push({
                                    top: characterPoint,
                                    bottom: characterPoint
                                });
                            else {
                                var lastPoint = location.d3.points[location.d3.points.length - 1];

                                // If the last points is from this 'time'
                                if (lastPoint.top.x == characterPoint.x) {
                                    // If the new point is 'higher' (lower Y), replace the top one
                                    if (lastPoint.top.y > characterPoint.y) {
                                        location.d3.points[location.d3.points.length - 1].top = characterPoint;
                                    } else if (lastPoint.bottom.y < characterPoint.y) {
                                        // If the new points is 'lower' (higher Y), replace the bottom one
                                        location.d3.points[location.d3.points.length - 1].bottom = characterPoint;
                                    }
                                } else {
                                    // First point of belonging to this 'time' -> nothing to check
                                    location.d3.points.push({
                                        top: characterPoint,
                                        bottom: characterPoint
                                    });
                                }
                            }
                        });
                    }
                }
            }
        }

        // Remove the locations which have no points
        // (because the characters which used to belong to it were removed)
        dataset.locations = dataset.locations.filter(function (location) {
            return location.d3.points != undefined;
        });

        // Split the locations
        // If the gap (on OX) between two characters that belong to the same location
        // is bigger that options.locations.splitLength, we artificially split the location
        // into two parts. Otherwise, the long interpolation between the two distant characters
        // looks out of place and overlaps with other location, cluttering the visualization
        for(i = 0; i < dataset.locations.length; ++i) {
            var location = dataset.locations[i];

            for (k = 1; k < location.d3.points.length; ++k) {
                if (location.d3.points[k].top.x - location.d3.points[k - 1].top.x > options.locations.splitLength) {
                    // Create the new (artificial location) as a hard copy of the current one
                    var newLocation       = jQuery.extend(true, {}, location);

                    // Assign to it the points that are too far away from the current location
                    newLocation.d3.points = newLocation.d3.points.slice(k);

                    // Assign a new id to the location
                    newLocation.id        = dataset.locations.length;

                    // Remove the points (from the current location) that are too far away
                    location.d3.points    = location.d3.points.slice(0, k);

                    // Append the new location (if it, in turn, contains another 'jump',
                    // this will be picked up by the the outer for loop and split again)
                    dataset.locations.push(newLocation);

                    // No need to process the remaining points
                    break;
                }
            }
        }

        // Handles what happens when a character line is clicked
        function toggleCharacterHighlight(character) {
            // Previously no characters were highlighted => fade all away
            if (dataset.d3.charactersHighlighted == 0)
                d3.selectAll("." + options.characters.class)
                        .transition()
                        .duration(options.characters.highlightDuration)
                        .style('opacity', options.characters.nonHighlightedOpacity)
                        .style('stroke-width', options.characters.strokeWidth);

            // Toggle the highlight state
            character.d3.isHighlighted = !character.d3.isHighlighted;
            dataset.d3.charactersHighlighted += character.d3.isHighlighted ? 1 : -1;

            // No characters are highlighted => unfade them
            if (dataset.d3.charactersHighlighted == 0)
                d3.selectAll("." + options.characters.class)
                        .transition()
                        .duration(options.characters.highlightDuration)
                        .style('opacity', 1.0)
                        .style('stroke-width', options.characters.strokeWidth);
        }

        var locationArea = d3.svg.area().interpolate(options.locations.interpolation)
                .x(function (d) {
                    return d.top.x;
                })
                .y0(function (d) {
                    return d.bottom.y + options.locations.padding
                })
                .y1(function (d) {
                    return d.top.y - options.locations.padding
                });

        // Sets the attributes for a location area
        // (an ID is defined for each area, so that we can 'bind' the labels to them)
        function setLocationAttributes(locations) {
            return locations
                    .attr("id", function (d) {
                        return options.locations.class + d.id;
                    })
                    .attr("class", options.locations.class)
                    .attr("d", function (d) {
                        return locationArea(d.d3.points);
                    })
                    .attr("fill", function (d) {
                        return d.d3.color;
                    })
                    .attr("opacity", options.locations.opacity);
        }

        // Update the location lines
        var locations = svg.selectAll("." + options.locations.class).data(dataset.locations).attr("class", options.locations.class);
        setLocationAttributes(locations.transition().duration(options.animation.transitionDuration));
        setLocationAttributes(locations.enter().append("path"));

        locations.exit().remove();

        // Sets the attributes for the location labels
        // ('bind' them to the right location)
        function setLocationNamesAttributes(locationNames) {
            return locationNames
                    .attr("class", options.locations.labelClass)
                    .attr("xlink:href", function (d, i) {
                        return "#" + options.locations.class + d.id;
                    })
                    .text(function (d, i) {
                        console.log(d, i);
                        return d.name;
                    });
        }

        // Update the location labels
        var locationNames = svg.selectAll("." + options.locations.labelClass).data(dataset.locations).attr("class", options.locations.labelClass);
        setLocationNamesAttributes(locationNames.transition().duration(options.animation.transitionDuration));
        setLocationNamesAttributes(locationNames.enter().append("text").attr("x", options.locations.labelX).attr("dy", options.locations.labelDy).style("font-size", options.locations.fontSize).append("textPath"));

        locationNames.exit().remove();

        dataset.d3.charactersHighlighted = 0;

        // When the background of the visualization is clicked, the highlited characters loose the highlight
        svg.on("click", function () {
            dataset.characters.forEach(function (character) {
                if (!character.isRemoved && character.d3.isHighlighted)

                    toggleCharacterHighlight(character);
            })
        });

        // Add 'dummy' data for the removed characters (avoids actually removing them and fixing the broken dependencies)
        // FIXME: This should not be necessary
        dataset.characters.forEach(function (character) {
            if (character.isRemoved)
                character.d3.points = [];
        });

        var line_function = d3.svg.line().interpolate(options.characters.interpolation)
                .x(function (d) {
                    return d.x;
                })
                .y(function (d) {
                    return d.y;
                });

        // Set the attributes for the character lines
        // (an ID is defined for each character, so that we can 'bind' the labels to them)
        function setCharacterLinesAttributes(lines) {
            return lines
                    .attr("class", options.characters.class)
                    .attr("id", function (d) {
                        return options.characters.class + d.id;
                    })
                    .attr("xlink:href", function (d) {
                        return options.characters.class + d.id;
                    })
                    .attr("d", function (d) {
                        return line_function(d.d3.points);
                    })
                    .attr("fill", "none")
                    .attr("stroke", function (d) {
                        return d.d3.color;
                    })
                    .attr("stroke-width", options.characters.strokeWidth)
                    .style('opacity', 1.0)
        }

        // Update the character lines
        var lines = svg.selectAll("." + options.characters.class).data(dataset.characters).attr("class", options.characters.class);
        setCharacterLinesAttributes(lines.transition().duration(options.animation.transitionDuration));
        setCharacterLinesAttributes(lines.enter().append("path"))
                .on("click", function (d) {
                    toggleCharacterHighlight(d);

                    d3.select(this)
                            .transition()
                            .duration(options.characters.highlightDuration)
                            .style('opacity', dataset.d3.charactersHighlighted == 0 || d.d3.isHighlighted ? 1.0 : options.characters.nonHighlightedOpacity)
                            .style('stroke-width', d.d3.isHighlighted ? options.characters.highlightStrokeWidth : options.characters.strokeWidth);

                    d3.event.stopPropagation();
                });

        lines.exit().remove();

        // Set the attributes for character labels
        // ('bind' them to the right characters)
        function setCharacterNamesAttributes(names) {
            return names
                    .attr("class", options.characters.labelClass)
                    .attr("xlink:href", function (d) {
                        return "#" + options.characters.class + d.id;
                    })
                    .text(function (d) {
                        return d.name;
                    });
        }

        // Update the character labels
        var names = svg.selectAll("." + options.characters.labelClass).data(dataset.characters).attr("class", options.characters.labelClass);
        setCharacterNamesAttributes(names.transition().duration(options.animation.transitionDuration));
        setCharacterNamesAttributes(names.enter().append("text").attr("x", options.characters.labelX)
                .attr("dy", options.characters.labelDy).append("textPath"));

        names.exit().remove();
    }

    // (Partial) Implementation of the algorithm presented in "StoryFlow: Tracking the Evolution of Stories"
    function annotateDataset(dataset, options) {
        // Compute the story timeframe
        var timeframe = dataset.sessions.map(function (x) {
            return {start: x.start, end: x.end}
        })
                .reduce(function (x, y) {
                    return {start: Math.min(x.start, y.start), end: Math.max(x.end, y.end)}
                });

        // Remove any characters that should not be displayed
        if (options.characters.toKeep != null) {
            // Remove the characters themselves
            dataset.characters.forEach(function (character) {
                character.isRemoved = (options.characters.toKeep.indexOf(String(character.id)) == -1);
            });

            // Remove the 'pointers' to these characters
            dataset.sessions.forEach(function (session) {
                session.members = session.members.filter(function (member) {
                    return options.characters.toKeep.indexOf(String(member)) != -1;
                })
            });

            // Remove sessions that are left with no characters
            dataset.sessions = dataset.sessions.filter(function (session) {
                return session.members.length != 0;
            })
        }

        /**
         * Rearranges the locations, session and characters in the given moment such that
         * the hierarchical constrains are met. 
         * @param moment the moment to optimize
         * @param charactersMapping a permutation of the characters which need to be applied to the moment
         * (if no reordering is needed, pass the identity permutation)
         * @param performSorting whether to sort the sessions and characters according to their weights
         */
        function optimizeMoment(moment, charactersMapping, performSorting) {
            // Place the locations with the highest number of characters first
            moment.locations.sort(function (x, y) {
                return x.sessions.map(function (x) {
                            return dataset.sessions[x].members.length;
                        })
                                .reduce(function (x, y) {
                                    return x + y;
                                }) <
                        y.sessions.map(function (y) {
                            return dataset.sessions[y].members.length;
                        })
                                .reduce(function (x, y) {
                                    return x + y;
                                });
            });

            // Sort the sessions according to their weights
            if (performSorting != undefined && performSorting == true)
                moment.locations.forEach(function (location) {
                    location.sessions.sort(function (x, y) {
                        var xWeight = dataset.sessions[x].members
                                        .map(function (x) {
                                            return charactersMapping[moment.sortedCharacters.indexOf(x)];
                                        })
                                        .reduce(function (x, y) {
                                            return x + y;
                                        })
                                / dataset.sessions[x].members.length;

                        var yWeight = dataset.sessions[y].members
                                        .map(function (y) {
                                            return charactersMapping[moment.sortedCharacters.indexOf(y)];
                                        })
                                        .reduce(function (x, y) {
                                            return x + y;
                                        })
                                / dataset.sessions[y].members.length;

                        return xWeight > yWeight;
                    });
                });

            // Combine all the characters from this moment into a hierarchical structure
            // and optionally sort them according to their weights
            var characters = moment.locations.map(function (x) {
                return x.sessions.map(function (x) {
                    var members = dataset.sessions[x].members;

                    if (performSorting != undefined && performSorting == true)
                        members.sort(function (x, y) {
                            return charactersMapping[moment.sortedCharacters.indexOf(x)] > charactersMapping[moment.sortedCharacters.indexOf(y)];
                        });

                    return members;
                })
            });

            moment.sortedCharacters = [];

            // Store the characters according to the hierarchy in an array
            characters.forEach(function (l) {
                l.forEach(function (s) {
                    s.forEach(function (c) {
                        moment.sortedCharacters.push(c);
                    })
                })
            });
        }

        dataset.d3 = {time: []};

        // Construct the relationship trees (one for each time unit)
        for (var time = timeframe.start; time < timeframe.end; ++time) {
            var moment = {locations: [], sortedCharacters: []};

            // Append the sessions and the characters that belong to this moment
            for (var i = 0; i < dataset.sessions.length; ++i) {
                var session  = dataset.sessions[i];
                var location = moment.locations[session.location];

                if (session.start <= time && time < session.end) {
                    if (location == undefined)
                        location = moment.locations[session.location] = {sessions: []};

                    location.sessions.push(i);
                }
            }

            // The moment may not contain any characters (them may have been removed)
            if (moment.locations.length != 0) {
                dataset.d3.time.push(moment);

                // Perform minimal optimizations (location sorting)
                optimizeMoment(moment, dataset.characters.map(function (_, i, _) {
                    return i;
                }), false);
            }
        }

        /**
         * Compute the realization matrix as defined in Methods for Visual Understanding of Hierarchical System Structures
         * @param referenceMoment moment containing the characters considered as 'fixed'
         * @param currentMoment moment containing the characters which will be reordered
         * @returns the realization matrix
         */
        function computeRealizationMatrix(referenceMoment, currentMoment) {
            var matrix = [];

            for (var r = 0; r < referenceMoment.length; ++r) {
                matrix[r] = [];

                for (var c = 0; c < currentMoment.length; ++c)
                    matrix[r][c] = referenceMoment[r] == currentMoment[c] ? 1 : 0;
            }

            return matrix;
        }

        /**
         * Compute the number of crossings in the given realization matrix
         * Algorithm from: Methods for Visual Understanding of Hierarchical System Structures
         * @param referenceMoment moment containing the characters considered as 'fixed'
         * @param currentMoment moment containing the characters which will be reordered
         * @returns the number of crossings
         */
        var computeCrossings = function (matrix, referenceMoment, currentMoment) {
            var crossings = 0;

            for (var topRow = 0; topRow < referenceMoment.length - 1; ++topRow)
                for (var bottomRow = topRow + 1; bottomRow < referenceMoment.length; ++bottomRow)
                    for (var leftColumn = 0; leftColumn < currentMoment.length - 1; ++leftColumn)
                        for (var rightColumn = leftColumn + 1; rightColumn < currentMoment.length; ++rightColumn)
                            crossings +=
                                    matrix[topRow][rightColumn] *
                                    matrix[bottomRow][leftColumn];

            return crossings;
        };

        /**
         * Sorts the characters from the current moment such that the number of crossing
         * with the reference moment is minimized
         * The reordering is done respecting the sort restrictions
         * Algorithm from: Methods for Visual Understanding of Hierarchical System Structures
         * @param referenceMoment moment containing the characters considered as 'fixed'
         * @param currentMoment moment containing the characters which will be reordered
         * @param sortRestrictions defined the groups of characters which can be reordered
         * @returns {{mapping: (*|Array), crossings: the}}
         */
        function sortMoment(referenceMoment, currentMoment, sortRestrictions) {
            var columnBarycenters = [];

            // Define the identity permutations
            var currentMapping    = currentMoment.map(function (_, i, _) {
                return i;
            });
            var backupMapping     = currentMoment.map(function (_, i, _) {
                return i;
            });

            var matrix            = computeRealizationMatrix(referenceMoment, currentMoment);

            // Compute the column barycenters
            for (c = 0; c < currentMoment.length; ++c) {
                var weightedSum = 0;

                for (r = 0; r < referenceMoment.length; ++r) {
                    weightedSum += (r + 1) * matrix[r][c];
                }

                columnBarycenters[c] = weightedSum;
            }

            // Compute the number of crossings before sorting the columns
            var crossingsBefore = computeCrossings(matrix, referenceMoment, currentMoment);

            // Sort the columns by their barycenters, while making sure that we respect the sorting restrictions
            for (var restriction = 0, offset = 0; restriction < sortRestrictions.length; ++restriction) {
                for (i = offset; i < offset + sortRestrictions[restriction]; ++i) {
                    for (var k = i + 1; k < offset + sortRestrictions[restriction]; ++k)
                        if (columnBarycenters[i] > columnBarycenters[k]) {
                            var tmp              = columnBarycenters[i];
                            columnBarycenters[i] = columnBarycenters[k];
                            columnBarycenters[k] = tmp;

                            tmp                               = currentMapping[currentMapping[i]];
                            currentMapping[currentMapping[i]] = currentMapping[currentMapping[k]];
                            currentMapping[currentMapping[k]] = tmp;

                            for (var r = 0; r < referenceMoment.length; ++r) {
                                var tmp                              = matrix[r][currentMapping[i]];
                                matrix[r][currentMapping.indexOf(i)] = matrix[r][currentMapping[k]];
                                matrix[r][currentMapping.indexOf(k)] = tmp;
                            }
                        }
                }

                offset += sortRestrictions[restriction];
            }

            // Compute the number of crossings after column sorting
            var crossingsAfter = computeCrossings(matrix, referenceMoment, currentMoment);

            // Return the original permutation if the number of crossings did not decrease
            if (crossingsBefore <= crossingsAfter) {
                return {mapping: backupMapping, crossings: crossingsBefore};
            }

            return {mapping: currentMapping, crossings: crossingsAfter};
        }

        // Store the best results so far
        // (the datasets will be hard-copied)
        var bestCrossings = -1;
        var bestDataset   = jQuery.extend(true, {}, dataset);

        // Perform sweeping
        // Iterate repeatedly through the moments and try to change the order of the characters
        // in order to minimize the number of crossings
        //
        // Steps:
        //   Sweep left -> right
        //     Sweep again to fix the order of the characters at each moment as the order in the last moment
        //   Sweep right -> left
        //     Sweep again to fix the order of the characters at each moment as the order in the last moment
        //
        // Between all these steps, check if an improvement was made and save it
        for (var iter = 0; iter < options.algorithm.sweepingMaxIterations; ++iter) {
            console.log("  Sweep #", iter);
            var totalCrossings = 0;

            // Sweep left->right
            for (t = 1; t < dataset.d3.time.length; ++t) {
                var referenceMoment = dataset.d3.time[t - 1];
                var currentMoment   = dataset.d3.time[t];

                var sortRestrictions = currentMoment.locations.
                        map(function (x) {
                            return x.sessions.map(function (x) {
                                return dataset.sessions[x].members.length;
                            })
                        }).
                        reduce(function (x, y) {
                            return x.concat(y);
                        });

                var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
                totalCrossings += result.crossings;

                optimizeMoment(currentMoment, result.mapping, true);
            }

            if (bestCrossings == -1 || bestCrossings >= totalCrossings) {
                bestCrossings = totalCrossings;
                bestDataset   = jQuery.extend(true, {}, dataset);
//                console.log("Best number of crossings: ", bestCrossings);
            }

            totalCrossings = 0;

            // Set the order for all time frames as the order at the last time frame
            referenceMoment = dataset.d3.time[dataset.d3.time.length - 2];
            currentMoment   = dataset.d3.time[dataset.d3.time.length - 1];

            // Sweep right->left to fix the order
            var sortRestrictions = currentMoment.locations.
                    map(function (x) {
                        return x.sessions.map(function (x) {
                            return dataset.sessions[x].members.length;
                        })
                    }).
                    reduce(function (x, y) {
                        return x.concat(y);
                    });


            var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

            for (t = 1; t < dataset.d3.time.length; ++t) {
                dataset.d3.time[t].sortedCharacters.sort(function (x, y) {
                    var xIndex = currentMoment.sortedCharacters.indexOf(x);
                    var yIndex = currentMoment.sortedCharacters.indexOf(x);

                    if (xIndex == -1) return false;
                    if (yIndex == -1) return false;

                    return result.mapping[xIndex] > result.mapping[yIndex];
                });

                var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function (_, i, _) {
                    return i;
                });

                optimizeMoment(dataset.d3.time[t], oneToOneMapping, false);

                var ref = dataset.d3.time[t - 1].sortedCharacters;
                var cur = dataset.d3.time[t].sortedCharacters;

                totalCrossings += computeCrossings(computeRealizationMatrix(ref, cur), ref, cur);
            }

            if (bestCrossings == -1 || bestCrossings >= totalCrossings) {
                bestCrossings = totalCrossings;
                bestDataset   = jQuery.extend(true, {}, dataset);
//                console.log("Best number of crossings: ", bestCrossings);
            }

            totalCrossings = 0;

            // Sweep right->left
            for (t = dataset.d3.time.length - 2; t >= 0; --t) {
                referenceMoment = dataset.d3.time[t + 1];
                currentMoment   = dataset.d3.time[t];

                var sortRestrictions = currentMoment.locations.
                        map(function (x) {
                            return x.sessions.map(function (x) {
                                return dataset.sessions[x].members.length;
                            })
                        }).
                        reduce(function (x, y) {
                            return x.concat(y);
                        });

                var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);
                totalCrossings += result.crossings;

                optimizeMoment(currentMoment, result.mapping, true);
            }

            if (bestCrossings == -1 || bestCrossings >= totalCrossings) {
                bestCrossings = totalCrossings;
                bestDataset   = jQuery.extend(true, {}, dataset);
//                console.log("Best number of crossings: ", bestCrossings);
            }

            totalCrossings = 0;

            // Set the order for all time frames as the order at the first time frame
            referenceMoment = dataset.d3.time[timeframe.start];
            currentMoment   = dataset.d3.time[timeframe.start + 1];

            // Sweep right->left to fix the order
            var sortRestrictions = currentMoment.locations.
                    map(function (x) {
                        return x.sessions.map(function (x) {
                            return dataset.sessions[x].members.length;
                        })
                    }).
                    reduce(function (x, y) {
                        return x.concat(y);
                    });


            var result = sortMoment(referenceMoment.sortedCharacters, currentMoment.sortedCharacters, sortRestrictions);

            for (t = 1; t < dataset.d3.time.length; ++t) {
                dataset.d3.time[t].sortedCharacters.sort(function (x, y) {
                    var xIndex = currentMoment.sortedCharacters.indexOf(x);
                    var yIndex = currentMoment.sortedCharacters.indexOf(x);

                    if (xIndex == -1) return false;
                    if (yIndex == -1) return false;

                    return result.mapping[xIndex] > result.mapping[yIndex];
                });

                var oneToOneMapping = dataset.d3.time[t].sortedCharacters.map(function (_, i, _) {
                    return i;
                });

                optimizeMoment(dataset.d3.time[t], oneToOneMapping, false);

                var ref = dataset.d3.time[t - 1].sortedCharacters;
                var cur = dataset.d3.time[t].sortedCharacters;

                totalCrossings += computeCrossings(computeRealizationMatrix(ref, cur), ref, cur);
            }

            if (bestCrossings == -1 || bestCrossings >= totalCrossings) {
                bestCrossings = totalCrossings;
                bestDataset   = jQuery.extend(true, {}, dataset);
//                console.log("Best number of crossings: ", bestCrossings);
            }
        }

        // The dataset with the least number of crossings is returned
        return bestDataset;
    }
</script>

<table>
    <tr>
        <td>
            <select name="dataset" id="dataset">
                <option value="dataset/the_matrix.json" selected>The Matrix</option>
                <option value="dataset/star_wars.json">Star Wars</option>
            </select>
        </td>
        <td>
            <select name="interpolation" id="interpolation">
                <option value="linear">Linear</option>
                <option value="step">Step</option>
                <option value="step-before">Step-before</option>
                <option value="step-after">Step-after</option>
                <option value="basis">Basis</option>
                <option value="bundle">Bundle</option>
                <option value="cardinal">Cardinal</option>
                <option value="monotone" selected>Monotone</option>
            </select>
        </td>
        <td>
            <select name="characters" id="characters" multiple="multiple"/>
        </td>
    </tr>
</table>

<div id="canvas"/>
</body>
</html>